module RedisQueuedLocks
  module Acquier
    module AcquireLock
      extend ::RedisQueuedLocks::Acquier::AcquireLock::TryToLock
      extend ::RedisQueuedLocks::Acquier::AcquireLock::DelayExecution
      extend ::RedisQueuedLocks::Acquier::AcquireLock::YieldExpire
      extend ::RedisQueuedLocks::Acquier::AcquireLock::WithAcqTimeout
      extend ::RedisQueuedLocks::Acquier::AcquireLock::DequeueFromLockQueue

      def self.acquire_lock: (
        ::RedisClient redis,
        ::String lock_name,
        process_id: ::Integer|::String,
        thread_id: ::Integer|::String,
        fiber_id: ::Integer|::String,
        ractor_id: ::Integer|::String,
        ttl: ::Integer?,
        queue_ttl: ::Integer,
        timeout: ::Integer,
        timed: bool,
        retry_count: ::Integer?,
        retry_delay: ::Integer,
        retry_jitter: ::Integer,
        raise_errors: bool,
        instrumenter: untyped, # [#notify]
        identity: ::String,
        fail_fast: bool,
        meta: ::Hash[String|Symbol,untyped]?,
        detailed_acq_timeout_error: bool,
        logger: ::Logger|::RedisQueuedLocks::_Loggable,
        log_lock_try: bool,
        instrument: untyped?,
        conflict_strategy: ::Symbol,
        access_strategy: ::Symbol,
        log_sampling_enabled: bool,
        log_sampling_percent: ::Integer,
        log_sampler: untyped,
        log_sample_this: bool,
        instr_sampling_enabled: bool,
        instr_sampling_percent: ::Integer,
        instr_sampler: ::RedisQueuedLocks::Instrument::_Sampler,
        instr_sample_this: bool
      ) { (?) -> untyped } -> (::RedisQueuedLocks::Data|{ ok: bool, result: untyped })
    end
  end
end
